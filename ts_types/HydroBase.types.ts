/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.7.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

export type Timestamp = Uint64;
export type Uint64 = string;
export type Binary = string;
export type Decimal = string;
export type Uint128 = string;
export type TokenInfoProviderInstantiateMsg = {
  lsm: {
    admin?: string | null;
    code_id: number;
    hub_transfer_channel_id: string;
    label: string;
    msg: Binary;
  };
} | {
  base: {
    denom: string;
    token_group_id: string;
  };
} | {
  token_info_provider_contract: {
    admin?: string | null;
    code_id: number;
    label: string;
    msg: Binary;
  };
};
export interface InstantiateMsg {
  cw721_collection_info?: CollectionInfo | null;
  first_round_start: Timestamp;
  gatekeeper?: InstantiateContractMsg | null;
  initial_whitelist: string[];
  lock_depth_limit: number;
  lock_epoch_length: number;
  lock_expiry_duration_seconds: number;
  lockup_conversion_fee_percent: Decimal;
  max_deployment_duration: number;
  max_locked_tokens: Uint128;
  round_length: number;
  round_lock_power_schedule: [number, Decimal][];
  slash_percentage_threshold: Decimal;
  slash_tokens_receiver_addr: string;
  token_info_providers: TokenInfoProviderInstantiateMsg[];
  tranches: TrancheInfo[];
  whitelist_admins: string[];
}
export interface CollectionInfo {
  name: string;
  symbol: string;
}
export interface InstantiateContractMsg {
  admin?: string | null;
  code_id: number;
  label: string;
  msg: Binary;
}
export interface TrancheInfo {
  metadata: string;
  name: string;
}
export type ExecuteMsg = {
  lock_tokens: {
    lock_duration: number;
    proof?: LockTokensProof | null;
  };
} | {
  refresh_lock_duration: {
    lock_duration: number;
    lock_ids: number[];
  };
} | {
  split_lock: {
    amount: Uint128;
    lock_id: number;
  };
} | {
  merge_locks: {
    lock_ids: number[];
  };
} | {
  unlock_tokens: {
    lock_ids?: number[] | null;
  };
} | {
  create_proposal: {
    deployment_duration: number;
    description: string;
    minimum_atom_liquidity_request: Uint128;
    round_id?: number | null;
    title: string;
    tranche_id: number;
  };
} | {
  vote: {
    proposals_votes: ProposalToLockups[];
    tranche_id: number;
  };
} | {
  unvote: {
    lock_ids: number[];
    tranche_id: number;
  };
} | {
  add_account_to_whitelist: {
    address: string;
  };
} | {
  remove_account_from_whitelist: {
    address: string;
  };
} | {
  update_config: {
    config: UpdateConfigData;
  };
} | {
  delete_configs: {
    timestamps: Timestamp[];
  };
} | {
  pause: {};
} | {
  add_tranche: {
    tranche: TrancheInfo;
  };
} | {
  edit_tranche: {
    tranche_id: number;
    tranche_metadata?: string | null;
    tranche_name?: string | null;
  };
} | {
  add_liquidity_deployment: {
    deployed_funds: Coin[];
    destinations: string[];
    funds_before_deployment: Coin[];
    proposal_id: number;
    remaining_rounds: number;
    round_id: number;
    total_rounds: number;
    tranche_id: number;
  };
} | {
  remove_liquidity_deployment: {
    proposal_id: number;
    round_id: number;
    tranche_id: number;
  };
} | {
  update_token_groups_ratios: {
    changes: TokenGroupRatioChange[];
  };
} | {
  add_token_info_provider: {
    token_info_provider: TokenInfoProviderInstantiateMsg;
  };
} | {
  remove_token_info_provider: {
    provider_id: string;
  };
} | {
  set_gatekeeper: {
    gatekeeper_addr?: string | null;
  };
} | {
  transfer_nft: {
    recipient: string;
    token_id: string;
  };
} | {
  send_nft: {
    contract: string;
    msg: Binary;
    token_id: string;
  };
} | {
  lock_tokens_then_send_nft: {
    contract: string;
    lock_duration: number;
    msg: Binary;
    proof?: LockTokensProof | null;
  };
} | {
  approve: {
    expires?: Expiration | null;
    spender: string;
    token_id: string;
  };
} | {
  revoke: {
    spender: string;
    token_id: string;
  };
} | {
  approve_all: {
    expires?: Expiration | null;
    operator: string;
  };
} | {
  revoke_all: {
    operator: string;
  };
} | {
  set_drop_token_info: {
    core_address: string;
    d_token_denom: string;
    puppeteer_address: string;
  };
} | {
  convert_lockup_to_dtoken: {
    lock_ids: number[];
  };
} | {
  convert_lockup: {
    lock_id: number;
    target_denom: string;
  };
} | {
  provide_conversion_funds: {};
} | {
  withdraw_conversion_funds: {
    funds_to_withdraw: Coin[];
  };
} | {
  slash_proposal_voters: {
    limit: number;
    proposal_id: number;
    round_id: number;
    slash_percent: Decimal;
    start_from: number;
    tranche_id: number;
  };
} | {
  buyout_pending_slash: {
    lock_id: number;
  };
};
export type Expiration = {
  at_height: number;
} | {
  at_time: Timestamp;
} | {
  never: {};
};
export interface LockTokensProof {
  maximum_amount: Uint128;
  proof: string[];
  sig_info?: SignatureInfo | null;
}
export interface SignatureInfo {
  claim_msg: Binary;
  signature: Binary;
}
export interface ProposalToLockups {
  lock_ids: number[];
  proposal_id: number;
}
export interface UpdateConfigData {
  activate_at: Timestamp;
  cw721_collection_info?: CollectionInfo | null;
  known_users_cap?: number | null;
  lock_depth_limit?: number | null;
  lock_expiry_duration_seconds?: number | null;
  lockup_conversion_fee_percent?: Decimal | null;
  max_deployment_duration?: number | null;
  max_locked_tokens?: number | null;
  slash_percentage_threshold?: Decimal | null;
  slash_tokens_receiver_addr?: string | null;
}
export interface Coin {
  amount: Uint128;
  denom: string;
}
export interface TokenGroupRatioChange {
  new_ratio: Decimal;
  old_ratio: Decimal;
  token_group_id: string;
}
export type QueryMsg = {
  constants: {};
} | {
  token_info_providers: {};
} | {
  gatekeeper: {};
} | {
  tranches: {};
} | {
  all_user_lockups: {
    address: string;
    limit: number;
    start_from: number;
  };
} | {
  specific_user_lockups: {
    address: string;
    lock_ids: number[];
  };
} | {
  all_user_lockups_with_tranche_infos: {
    address: string;
    limit: number;
    start_from: number;
  };
} | {
  specific_user_lockups_with_tranche_infos: {
    address: string;
    lock_ids: number[];
  };
} | {
  expired_user_lockups: {
    address: string;
    limit: number;
    start_from: number;
  };
} | {
  lockups_pending_slashes: {
    lockup_ids: number[];
  };
} | {
  user_voting_power: {
    address: string;
  };
} | {
  user_votes: {
    address: string;
    round_id: number;
    tranche_id: number;
  };
} | {
  user_voted_locks: {
    proposal_id?: number | null;
    round_id: number;
    tranche_id: number;
    user_address: string;
  };
} | {
  lock_votes_history: {
    lock_id: number;
    start_from_round_id?: number | null;
    stop_at_round_id?: number | null;
    tranche_id?: number | null;
  };
} | {
  all_votes: {
    limit: number;
    start_from: number;
  };
} | {
  all_votes_round_tranche: {
    limit: number;
    round_id: number;
    start_from: number;
    tranche_id: number;
  };
} | {
  current_round: {};
} | {
  round_end: {
    round_id: number;
  };
} | {
  round_total_voting_power: {
    round_id: number;
  };
} | {
  round_proposals: {
    limit: number;
    round_id: number;
    start_from: number;
    tranche_id: number;
  };
} | {
  proposal: {
    proposal_id: number;
    round_id: number;
    tranche_id: number;
  };
} | {
  top_n_proposals: {
    number_of_proposals: number;
    round_id: number;
    tranche_id: number;
  };
} | {
  whitelist: {};
} | {
  whitelist_admins: {};
} | {
  total_locked_tokens: {};
} | {
  can_lock_denom: {
    token_denom: string;
  };
} | {
  liquidity_deployment: {
    proposal_id: number;
    round_id: number;
    tranche_id: number;
  };
} | {
  round_tranche_liquidity_deployments: {
    limit: number;
    round_id: number;
    start_from: number;
    tranche_id: number;
  };
} | {
  total_power_at_height: {
    height?: number | null;
  };
} | {
  voting_power_at_height: {
    address: string;
    height?: number | null;
  };
} | {
  slashable_token_num_for_voting_on_proposal: {
    proposal_id: number;
    round_id: number;
    tranche_id: number;
  };
} | {
  owner_of: {
    include_expired?: boolean | null;
    token_id: string;
  };
} | {
  approval: {
    include_expired?: boolean | null;
    spender: string;
    token_id: string;
  };
} | {
  approvals: {
    include_expired?: boolean | null;
    token_id: string;
  };
} | {
  all_operators: {
    include_expired?: boolean | null;
    limit?: number | null;
    owner: string;
    start_after?: string | null;
  };
} | {
  num_tokens: {};
} | {
  collection_info: {};
} | {
  nft_info: {
    token_id: string;
  };
} | {
  all_nft_info: {
    include_expired?: boolean | null;
    token_id: string;
  };
} | {
  tokens: {
    limit?: number | null;
    owner: string;
    start_after?: string | null;
  };
} | {
  all_tokens: {
    limit?: number | null;
    start_after?: string | null;
  };
} | {
  simulate_dtoken_amounts: {
    address: string;
    lock_ids: number[];
  };
} | {
  parent_lock_ids: {
    child_id: number;
  };
} | {
  lockup_voting_metrics: {
    lock_ids: number[];
  };
} | {
  available_conversion_funds: {
    token_denom: string;
  };
} | {
  all_available_conversion_funds: {
    limit?: number | null;
    round_id: number;
    start_after?: string | null;
  };
} | {
  converted_token_num: {
    lock_id: number;
    token_denom: string;
    user_provides_funds: boolean;
  };
};
export interface AllAvailableConversionFundsResponse {
  funds: ConversionFundInfo[];
  has_more: boolean;
  round_id: number;
  total_base_token_equivalent: Uint128;
}
export interface ConversionFundInfo {
  amount: Uint128;
  base_token_equivalent: Uint128;
  denom: string;
  ratio: Decimal;
}
export type Addr = string;
export interface AllNftInfoResponse {
  access: OwnerOfResponse;
  info: NftInfoResponse;
}
export interface OwnerOfResponse {
  approvals: Approval[];
  owner: string;
}
export interface Approval {
  expires: Expiration;
  spender: string;
}
export interface NftInfoResponse {
  extension: LockupWithPerTrancheInfo;
  token_uri?: string | null;
}
export interface LockupWithPerTrancheInfo {
  lock_with_power: LockEntryWithPower;
  per_tranche_info: PerTrancheLockupInfo[];
}
export interface LockEntryWithPower {
  current_voting_power: Uint128;
  lock_entry: LockEntryV2;
}
export interface LockEntryV2 {
  funds: Coin;
  lock_end: Timestamp;
  lock_id: number;
  lock_start: Timestamp;
  owner: Addr;
}
export interface PerTrancheLockupInfo {
  current_voted_on_proposal?: number | null;
  historic_voted_on_proposals: RoundWithBid[];
  next_round_lockup_can_vote: number;
  tied_to_proposal?: number | null;
  tranche_id: number;
}
export interface RoundWithBid {
  proposal_id: number;
  round_end: Timestamp;
  round_id: number;
}
export interface OperatorsResponse {
  operators: Approval[];
}
export interface TokensResponse {
  tokens: string[];
}
export interface AllUserLockupsResponse {
  lockups: LockEntryWithPower[];
}
export interface AllUserLockupsWithTrancheInfosResponse {
  lockups_with_per_tranche_infos: LockupWithPerTrancheInfo[];
}
export interface AllVotesResponse {
  votes: VoteEntry[];
}
export interface VoteEntry {
  lock_id: number;
  round_id: number;
  sender_addr: Addr;
  tranche_id: number;
  vote: Vote;
}
export interface Vote {
  prop_id: number;
  time_weighted_shares: [string, Decimal];
}
export interface AllVotesRoundTrancheResponse {
  votes: VoteEntry[];
}
export interface ApprovalResponse {
  approval: Approval;
}
export interface ApprovalsResponse {
  approvals: Approval[];
}
export interface CanLockDenomResponse {
  can_be_locked: boolean;
  denom: string;
}
export interface ConstantsResponse {
  constants: Constants;
}
export interface Constants {
  cw721_collection_info: CollectionInfo;
  first_round_start: Timestamp;
  known_users_cap: number;
  lock_depth_limit: number;
  lock_epoch_length: number;
  lock_expiry_duration_seconds: number;
  lockup_conversion_fee_percent: Decimal;
  max_deployment_duration: number;
  max_locked_tokens: number;
  paused: boolean;
  round_length: number;
  round_lock_power_schedule: RoundLockPowerSchedule;
  slash_percentage_threshold: Decimal;
  slash_tokens_receiver_addr: string;
}
export interface RoundLockPowerSchedule {
  round_lock_power_schedule: LockPowerEntry[];
}
export interface LockPowerEntry {
  locked_rounds: number;
  power_scaling_factor: Decimal;
}
export interface CurrentRoundResponse {
  round_end: Timestamp;
  round_id: number;
}
export interface ExpiredUserLockupsResponse {
  lockups: LockEntryV2[];
}
export interface GatekeeperResponse {
  gatekeeper: string;
}
export interface LiquidityDeploymentResponse {
  liquidity_deployment: LiquidityDeployment;
}
export interface LiquidityDeployment {
  deployed_funds: Coin[];
  destinations: string[];
  funds_before_deployment: Coin[];
  proposal_id: number;
  remaining_rounds: number;
  round_id: number;
  total_rounds: number;
  tranche_id: number;
}
export interface LockVotesHistoryResponse {
  vote_history: LockVotesHistoryEntry[];
}
export interface LockVotesHistoryEntry {
  proposal_id: number;
  round_id: number;
  tranche_id: number;
  vote_power: Decimal;
}
export interface LockupVotingMetricsResponse {
  lockups: LockupVotingMetrics[];
}
export interface LockupVotingMetrics {
  lock_id: number;
  locked_rounds_remaining: number;
  time_weighted_shares: Uint128;
  token_group_id: string;
}
export interface LockupsPendingSlashesResponse {
  pending_slashes: [number, Uint128 | null][];
}
export interface NumTokensResponse {
  count: number;
}
export interface ParentLockIdsResponse {
  parent_ids: number[];
}
export interface ProposalResponse {
  proposal: Proposal;
}
export interface Proposal {
  deployment_duration: number;
  description: string;
  minimum_atom_liquidity_request: Uint128;
  percentage: Uint128;
  power: Uint128;
  proposal_id: number;
  round_id: number;
  title: string;
  tranche_id: number;
}
export interface RoundEndResponse {
  round_end: Timestamp;
}
export interface RoundProposalsResponse {
  proposals: Proposal[];
}
export interface RoundTotalVotingPowerResponse {
  total_voting_power: Uint128;
}
export interface RoundTrancheLiquidityDeploymentsResponse {
  liquidity_deployments: LiquidityDeployment[];
}
export interface DtokenAmountsResponse {
  dtokens_response: DtokenAmountResponse[];
}
export interface DtokenAmountResponse {
  dtoken_amount: string;
  lock_id: number;
}
export interface SpecificUserLockupsResponse {
  lockups: LockEntryWithPower[];
}
export interface SpecificUserLockupsWithTrancheInfosResponse {
  lockups_with_per_tranche_infos: LockupWithPerTrancheInfo[];
}
export type TokenInfoProvider = {
  lsm: TokenInfoProviderLSM;
} | {
  base: TokenInfoProviderBase;
} | {
  derivative: TokenInfoProviderDerivative;
};
export interface TokenInfoProvidersResponse {
  providers: TokenInfoProvider[];
}
export interface TokenInfoProviderLSM {
  cache: {};
  contract: string;
  hub_transfer_channel_id: string;
}
export interface TokenInfoProviderBase {
  denom: string;
  ratio: Decimal;
  token_group_id: string;
}
export interface TokenInfoProviderDerivative {
  cache: {};
  contract: string;
}
export interface TopNProposalsResponse {
  proposals: Proposal[];
}
export interface TotalLockedTokensResponse {
  total_locked_tokens: number;
}
export interface TotalPowerAtHeightResponse {
  height: number;
  power: Uint128;
}
export interface TranchesResponse {
  tranches: Tranche[];
}
export interface Tranche {
  id: number;
  metadata: string;
  name: string;
}
export interface UserVotedLocksResponse {
  voted_locks: [number, VotedLockInfo[]][];
}
export interface VotedLockInfo {
  lock_id: number;
  vote_power: Decimal;
}
export interface UserVotesResponse {
  votes: VoteWithPower[];
}
export interface VoteWithPower {
  power: Decimal;
  prop_id: number;
}
export interface UserVotingPowerResponse {
  voting_power: number;
}
export interface VotingPowerAtHeightResponse {
  height: number;
  power: Uint128;
}
export interface WhitelistResponse {
  whitelist: Addr[];
}
export interface WhitelistAdminsResponse {
  admins: Addr[];
}