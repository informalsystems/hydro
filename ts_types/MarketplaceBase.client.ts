/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, Collection, CollectionConfig, ExecuteMsg, Uint128, Coin, QueryMsg, EventAction, EventsResponse, Event, Addr, ListingResponse, Listing, ListingsResponse, ListingsByCollectionResponse, ListingsByOwnerResponse, WhitelistedCollectionsResponse } from "./MarketplaceBase.types";
export interface MarketplaceBaseReadOnlyInterface {
  contractAddress: string;
  listing: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }) => Promise<ListingResponse>;
  listings: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<ListingsResponse>;
  listingsByOwner: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }) => Promise<ListingsByOwnerResponse>;
  listingsByCollection: ({
    collection,
    limit,
    startAfter
  }: {
    collection: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<ListingsByCollectionResponse>;
  whitelistedCollections: () => Promise<WhitelistedCollectionsResponse>;
  events: ({
    collection,
    limit,
    startAfter,
    tokenId
  }: {
    collection: string;
    limit?: number;
    startAfter?: number;
    tokenId: string;
  }) => Promise<EventsResponse>;
}
export class MarketplaceBaseQueryClient implements MarketplaceBaseReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.listing = this.listing.bind(this);
    this.listings = this.listings.bind(this);
    this.listingsByOwner = this.listingsByOwner.bind(this);
    this.listingsByCollection = this.listingsByCollection.bind(this);
    this.whitelistedCollections = this.whitelistedCollections.bind(this);
    this.events = this.events.bind(this);
  }
  listing = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }): Promise<ListingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      listing: {
        collection,
        token_id: tokenId
      }
    });
  };
  listings = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<ListingsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      listings: {
        limit,
        start_after: startAfter
      }
    });
  };
  listingsByOwner = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }): Promise<ListingsByOwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      listings_by_owner: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  listingsByCollection = async ({
    collection,
    limit,
    startAfter
  }: {
    collection: string;
    limit?: number;
    startAfter?: number;
  }): Promise<ListingsByCollectionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      listings_by_collection: {
        collection,
        limit,
        start_after: startAfter
      }
    });
  };
  whitelistedCollections = async (): Promise<WhitelistedCollectionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      whitelisted_collections: {}
    });
  };
  events = async ({
    collection,
    limit,
    startAfter,
    tokenId
  }: {
    collection: string;
    limit?: number;
    startAfter?: number;
    tokenId: string;
  }): Promise<EventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      events: {
        collection,
        limit,
        start_after: startAfter,
        token_id: tokenId
      }
    });
  };
}
export interface MarketplaceBaseInterface extends MarketplaceBaseReadOnlyInterface {
  contractAddress: string;
  sender: string;
  buy: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  unlist: ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  list: ({
    collection,
    price,
    tokenId
  }: {
    collection: string;
    price: Coin;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  addOrUpdateCollection: ({
    collectionAddress,
    config
  }: {
    collectionAddress: string;
    config: CollectionConfig;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  removeCollection: ({
    collection
  }: {
    collection: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  proposeNewAdmin: ({
    newAdmin
  }: {
    newAdmin?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  claimAdminRole: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class MarketplaceBaseClient extends MarketplaceBaseQueryClient implements MarketplaceBaseInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.buy = this.buy.bind(this);
    this.unlist = this.unlist.bind(this);
    this.list = this.list.bind(this);
    this.addOrUpdateCollection = this.addOrUpdateCollection.bind(this);
    this.removeCollection = this.removeCollection.bind(this);
    this.proposeNewAdmin = this.proposeNewAdmin.bind(this);
    this.claimAdminRole = this.claimAdminRole.bind(this);
  }
  buy = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      buy: {
        collection,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  unlist = async ({
    collection,
    tokenId
  }: {
    collection: string;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unlist: {
        collection,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  list = async ({
    collection,
    price,
    tokenId
  }: {
    collection: string;
    price: Coin;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      list: {
        collection,
        price,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  addOrUpdateCollection = async ({
    collectionAddress,
    config
  }: {
    collectionAddress: string;
    config: CollectionConfig;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_or_update_collection: {
        collection_address: collectionAddress,
        config
      }
    }, fee_, memo_, funds_);
  };
  removeCollection = async ({
    collection
  }: {
    collection: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_collection: {
        collection
      }
    }, fee_, memo_, funds_);
  };
  proposeNewAdmin = async ({
    newAdmin
  }: {
    newAdmin?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_new_admin: {
        new_admin: newAdmin
      }
    }, fee_, memo_, funds_);
  };
  claimAdminRole = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_admin_role: {}
    }, fee_, memo_, funds_);
  };
}