/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Timestamp, Uint64, Binary, Uint128, Decimal, TokenInfoProviderInstantiateMsg, InstantiateMsg, CollectionInfo, InstantiateContractMsg, TrancheInfo, ExecuteMsg, Expiration, LockTokensProof, SignatureInfo, ProposalToLockups, UpdateConfigData, Coin, TokenGroupRatioChange, QueryMsg, Addr, AllNftInfoResponse, OwnerOfResponse, Approval, NftInfoResponse, LockupWithPerTrancheInfo, LockEntryWithPower, LockEntryV2, PerTrancheLockupInfo, RoundWithBid, OperatorsResponse, TokensResponse, AllUserLockupsResponse, AllUserLockupsWithTrancheInfosResponse, AllVotesResponse, VoteEntry, Vote, AllVotesRoundTrancheResponse, ApprovalResponse, ApprovalsResponse, CanLockDenomResponse, ConstantsResponse, Constants, RoundLockPowerSchedule, LockPowerEntry, CurrentRoundResponse, ExpiredUserLockupsResponse, GatekeeperResponse, LiquidityDeploymentResponse, LiquidityDeployment, LockVotesHistoryResponse, LockVotesHistoryEntry, LockupsPendingSlashesResponse, NumTokensResponse, ProposalResponse, Proposal, RoundEndResponse, RoundProposalsResponse, RoundTotalVotingPowerResponse, RoundTrancheLiquidityDeploymentsResponse, DtokenAmountsResponse, DtokenAmountResponse, SpecificUserLockupsResponse, SpecificUserLockupsWithTrancheInfosResponse, TokenInfoProvider, TokenInfoProvidersResponse, TokenInfoProviderLSM, TokenInfoProviderBase, TokenInfoProviderDerivative, TopNProposalsResponse, TotalLockedTokensResponse, TotalPowerAtHeightResponse, TranchesResponse, Tranche, UserVotedLocksResponse, VotedLockInfo, UserVotesResponse, VoteWithPower, UserVotingPowerResponse, VotingPowerAtHeightResponse, WhitelistResponse, WhitelistAdminsResponse } from "./HydroBase.types";
export interface HydroBaseReadOnlyInterface {
  contractAddress: string;
  constants: () => Promise<ConstantsResponse>;
  tokenInfoProviders: () => Promise<TokenInfoProvidersResponse>;
  gatekeeper: () => Promise<GatekeeperResponse>;
  tranches: () => Promise<TranchesResponse>;
  allUserLockups: ({
    address,
    limit,
    startFrom
  }: {
    address: string;
    limit: number;
    startFrom: number;
  }) => Promise<AllUserLockupsResponse>;
  specificUserLockups: ({
    address,
    lockIds
  }: {
    address: string;
    lockIds: number[];
  }) => Promise<SpecificUserLockupsResponse>;
  allUserLockupsWithTrancheInfos: ({
    address,
    limit,
    startFrom
  }: {
    address: string;
    limit: number;
    startFrom: number;
  }) => Promise<AllUserLockupsWithTrancheInfosResponse>;
  specificUserLockupsWithTrancheInfos: ({
    address,
    lockIds
  }: {
    address: string;
    lockIds: number[];
  }) => Promise<SpecificUserLockupsWithTrancheInfosResponse>;
  expiredUserLockups: ({
    address,
    limit,
    startFrom
  }: {
    address: string;
    limit: number;
    startFrom: number;
  }) => Promise<ExpiredUserLockupsResponse>;
  lockupsPendingSlashes: ({
    lockupIds
  }: {
    lockupIds: number[];
  }) => Promise<LockupsPendingSlashesResponse>;
  userVotingPower: ({
    address
  }: {
    address: string;
  }) => Promise<UserVotingPowerResponse>;
  userVotes: ({
    address,
    roundId,
    trancheId
  }: {
    address: string;
    roundId: number;
    trancheId: number;
  }) => Promise<UserVotesResponse>;
  userVotedLocks: ({
    proposalId,
    roundId,
    trancheId,
    userAddress
  }: {
    proposalId?: number;
    roundId: number;
    trancheId: number;
    userAddress: string;
  }) => Promise<UserVotedLocksResponse>;
  lockVotesHistory: ({
    lockId,
    startFromRoundId,
    stopAtRoundId,
    trancheId
  }: {
    lockId: number;
    startFromRoundId?: number;
    stopAtRoundId?: number;
    trancheId?: number;
  }) => Promise<LockVotesHistoryResponse>;
  allVotes: ({
    limit,
    startFrom
  }: {
    limit: number;
    startFrom: number;
  }) => Promise<AllVotesResponse>;
  allVotesRoundTranche: ({
    limit,
    roundId,
    startFrom,
    trancheId
  }: {
    limit: number;
    roundId: number;
    startFrom: number;
    trancheId: number;
  }) => Promise<AllVotesRoundTrancheResponse>;
  currentRound: () => Promise<CurrentRoundResponse>;
  roundEnd: ({
    roundId
  }: {
    roundId: number;
  }) => Promise<RoundEndResponse>;
  roundTotalVotingPower: ({
    roundId
  }: {
    roundId: number;
  }) => Promise<RoundTotalVotingPowerResponse>;
  roundProposals: ({
    limit,
    roundId,
    startFrom,
    trancheId
  }: {
    limit: number;
    roundId: number;
    startFrom: number;
    trancheId: number;
  }) => Promise<RoundProposalsResponse>;
  proposal: ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }) => Promise<ProposalResponse>;
  topNProposals: ({
    numberOfProposals,
    roundId,
    trancheId
  }: {
    numberOfProposals: number;
    roundId: number;
    trancheId: number;
  }) => Promise<TopNProposalsResponse>;
  whitelist: () => Promise<WhitelistResponse>;
  whitelistAdmins: () => Promise<WhitelistAdminsResponse>;
  totalLockedTokens: () => Promise<TotalLockedTokensResponse>;
  canLockDenom: ({
    tokenDenom
  }: {
    tokenDenom: string;
  }) => Promise<CanLockDenomResponse>;
  liquidityDeployment: ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }) => Promise<LiquidityDeploymentResponse>;
  roundTrancheLiquidityDeployments: ({
    limit,
    roundId,
    startFrom,
    trancheId
  }: {
    limit: number;
    roundId: number;
    startFrom: number;
    trancheId: number;
  }) => Promise<RoundTrancheLiquidityDeploymentsResponse>;
  totalPowerAtHeight: ({
    height
  }: {
    height?: number;
  }) => Promise<TotalPowerAtHeightResponse>;
  votingPowerAtHeight: ({
    address,
    height
  }: {
    address: string;
    height?: number;
  }) => Promise<VotingPowerAtHeightResponse>;
  slashableTokenNumForVotingOnProposal: ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }) => Promise<Uint128>;
  ownerOf: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<OwnerOfResponse>;
  approval: ({
    includeExpired,
    spender,
    tokenId
  }: {
    includeExpired?: boolean;
    spender: string;
    tokenId: string;
  }) => Promise<ApprovalResponse>;
  approvals: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<ApprovalsResponse>;
  allOperators: ({
    includeExpired,
    limit,
    owner,
    startAfter
  }: {
    includeExpired?: boolean;
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<OperatorsResponse>;
  numTokens: () => Promise<NumTokensResponse>;
  collectionInfo: () => Promise<CollectionInfo>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: string;
  }) => Promise<NftInfoResponse>;
  allNftInfo: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }) => Promise<AllNftInfoResponse>;
  tokens: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<TokensResponse>;
  simulateDtokenAmounts: ({
    address,
    lockIds
  }: {
    address: string;
    lockIds: number[];
  }) => Promise<DtokenAmountsResponse>;
}
export class HydroBaseQueryClient implements HydroBaseReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.constants = this.constants.bind(this);
    this.tokenInfoProviders = this.tokenInfoProviders.bind(this);
    this.gatekeeper = this.gatekeeper.bind(this);
    this.tranches = this.tranches.bind(this);
    this.allUserLockups = this.allUserLockups.bind(this);
    this.specificUserLockups = this.specificUserLockups.bind(this);
    this.allUserLockupsWithTrancheInfos = this.allUserLockupsWithTrancheInfos.bind(this);
    this.specificUserLockupsWithTrancheInfos = this.specificUserLockupsWithTrancheInfos.bind(this);
    this.expiredUserLockups = this.expiredUserLockups.bind(this);
    this.lockupsPendingSlashes = this.lockupsPendingSlashes.bind(this);
    this.userVotingPower = this.userVotingPower.bind(this);
    this.userVotes = this.userVotes.bind(this);
    this.userVotedLocks = this.userVotedLocks.bind(this);
    this.lockVotesHistory = this.lockVotesHistory.bind(this);
    this.allVotes = this.allVotes.bind(this);
    this.allVotesRoundTranche = this.allVotesRoundTranche.bind(this);
    this.currentRound = this.currentRound.bind(this);
    this.roundEnd = this.roundEnd.bind(this);
    this.roundTotalVotingPower = this.roundTotalVotingPower.bind(this);
    this.roundProposals = this.roundProposals.bind(this);
    this.proposal = this.proposal.bind(this);
    this.topNProposals = this.topNProposals.bind(this);
    this.whitelist = this.whitelist.bind(this);
    this.whitelistAdmins = this.whitelistAdmins.bind(this);
    this.totalLockedTokens = this.totalLockedTokens.bind(this);
    this.canLockDenom = this.canLockDenom.bind(this);
    this.liquidityDeployment = this.liquidityDeployment.bind(this);
    this.roundTrancheLiquidityDeployments = this.roundTrancheLiquidityDeployments.bind(this);
    this.totalPowerAtHeight = this.totalPowerAtHeight.bind(this);
    this.votingPowerAtHeight = this.votingPowerAtHeight.bind(this);
    this.slashableTokenNumForVotingOnProposal = this.slashableTokenNumForVotingOnProposal.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.approval = this.approval.bind(this);
    this.approvals = this.approvals.bind(this);
    this.allOperators = this.allOperators.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.collectionInfo = this.collectionInfo.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.allNftInfo = this.allNftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
    this.simulateDtokenAmounts = this.simulateDtokenAmounts.bind(this);
  }
  constants = async (): Promise<ConstantsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      constants: {}
    });
  };
  tokenInfoProviders = async (): Promise<TokenInfoProvidersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_info_providers: {}
    });
  };
  gatekeeper = async (): Promise<GatekeeperResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      gatekeeper: {}
    });
  };
  tranches = async (): Promise<TranchesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tranches: {}
    });
  };
  allUserLockups = async ({
    address,
    limit,
    startFrom
  }: {
    address: string;
    limit: number;
    startFrom: number;
  }): Promise<AllUserLockupsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_user_lockups: {
        address,
        limit,
        start_from: startFrom
      }
    });
  };
  specificUserLockups = async ({
    address,
    lockIds
  }: {
    address: string;
    lockIds: number[];
  }): Promise<SpecificUserLockupsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      specific_user_lockups: {
        address,
        lock_ids: lockIds
      }
    });
  };
  allUserLockupsWithTrancheInfos = async ({
    address,
    limit,
    startFrom
  }: {
    address: string;
    limit: number;
    startFrom: number;
  }): Promise<AllUserLockupsWithTrancheInfosResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_user_lockups_with_tranche_infos: {
        address,
        limit,
        start_from: startFrom
      }
    });
  };
  specificUserLockupsWithTrancheInfos = async ({
    address,
    lockIds
  }: {
    address: string;
    lockIds: number[];
  }): Promise<SpecificUserLockupsWithTrancheInfosResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      specific_user_lockups_with_tranche_infos: {
        address,
        lock_ids: lockIds
      }
    });
  };
  expiredUserLockups = async ({
    address,
    limit,
    startFrom
  }: {
    address: string;
    limit: number;
    startFrom: number;
  }): Promise<ExpiredUserLockupsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      expired_user_lockups: {
        address,
        limit,
        start_from: startFrom
      }
    });
  };
  lockupsPendingSlashes = async ({
    lockupIds
  }: {
    lockupIds: number[];
  }): Promise<LockupsPendingSlashesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      lockups_pending_slashes: {
        lockup_ids: lockupIds
      }
    });
  };
  userVotingPower = async ({
    address
  }: {
    address: string;
  }): Promise<UserVotingPowerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_voting_power: {
        address
      }
    });
  };
  userVotes = async ({
    address,
    roundId,
    trancheId
  }: {
    address: string;
    roundId: number;
    trancheId: number;
  }): Promise<UserVotesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_votes: {
        address,
        round_id: roundId,
        tranche_id: trancheId
      }
    });
  };
  userVotedLocks = async ({
    proposalId,
    roundId,
    trancheId,
    userAddress
  }: {
    proposalId?: number;
    roundId: number;
    trancheId: number;
    userAddress: string;
  }): Promise<UserVotedLocksResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_voted_locks: {
        proposal_id: proposalId,
        round_id: roundId,
        tranche_id: trancheId,
        user_address: userAddress
      }
    });
  };
  lockVotesHistory = async ({
    lockId,
    startFromRoundId,
    stopAtRoundId,
    trancheId
  }: {
    lockId: number;
    startFromRoundId?: number;
    stopAtRoundId?: number;
    trancheId?: number;
  }): Promise<LockVotesHistoryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      lock_votes_history: {
        lock_id: lockId,
        start_from_round_id: startFromRoundId,
        stop_at_round_id: stopAtRoundId,
        tranche_id: trancheId
      }
    });
  };
  allVotes = async ({
    limit,
    startFrom
  }: {
    limit: number;
    startFrom: number;
  }): Promise<AllVotesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_votes: {
        limit,
        start_from: startFrom
      }
    });
  };
  allVotesRoundTranche = async ({
    limit,
    roundId,
    startFrom,
    trancheId
  }: {
    limit: number;
    roundId: number;
    startFrom: number;
    trancheId: number;
  }): Promise<AllVotesRoundTrancheResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_votes_round_tranche: {
        limit,
        round_id: roundId,
        start_from: startFrom,
        tranche_id: trancheId
      }
    });
  };
  currentRound = async (): Promise<CurrentRoundResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      current_round: {}
    });
  };
  roundEnd = async ({
    roundId
  }: {
    roundId: number;
  }): Promise<RoundEndResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      round_end: {
        round_id: roundId
      }
    });
  };
  roundTotalVotingPower = async ({
    roundId
  }: {
    roundId: number;
  }): Promise<RoundTotalVotingPowerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      round_total_voting_power: {
        round_id: roundId
      }
    });
  };
  roundProposals = async ({
    limit,
    roundId,
    startFrom,
    trancheId
  }: {
    limit: number;
    roundId: number;
    startFrom: number;
    trancheId: number;
  }): Promise<RoundProposalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      round_proposals: {
        limit,
        round_id: roundId,
        start_from: startFrom,
        tranche_id: trancheId
      }
    });
  };
  proposal = async ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }): Promise<ProposalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      proposal: {
        proposal_id: proposalId,
        round_id: roundId,
        tranche_id: trancheId
      }
    });
  };
  topNProposals = async ({
    numberOfProposals,
    roundId,
    trancheId
  }: {
    numberOfProposals: number;
    roundId: number;
    trancheId: number;
  }): Promise<TopNProposalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      top_n_proposals: {
        number_of_proposals: numberOfProposals,
        round_id: roundId,
        tranche_id: trancheId
      }
    });
  };
  whitelist = async (): Promise<WhitelistResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      whitelist: {}
    });
  };
  whitelistAdmins = async (): Promise<WhitelistAdminsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      whitelist_admins: {}
    });
  };
  totalLockedTokens = async (): Promise<TotalLockedTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_locked_tokens: {}
    });
  };
  canLockDenom = async ({
    tokenDenom
  }: {
    tokenDenom: string;
  }): Promise<CanLockDenomResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      can_lock_denom: {
        token_denom: tokenDenom
      }
    });
  };
  liquidityDeployment = async ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }): Promise<LiquidityDeploymentResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      liquidity_deployment: {
        proposal_id: proposalId,
        round_id: roundId,
        tranche_id: trancheId
      }
    });
  };
  roundTrancheLiquidityDeployments = async ({
    limit,
    roundId,
    startFrom,
    trancheId
  }: {
    limit: number;
    roundId: number;
    startFrom: number;
    trancheId: number;
  }): Promise<RoundTrancheLiquidityDeploymentsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      round_tranche_liquidity_deployments: {
        limit,
        round_id: roundId,
        start_from: startFrom,
        tranche_id: trancheId
      }
    });
  };
  totalPowerAtHeight = async ({
    height
  }: {
    height?: number;
  }): Promise<TotalPowerAtHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_power_at_height: {
        height
      }
    });
  };
  votingPowerAtHeight = async ({
    address,
    height
  }: {
    address: string;
    height?: number;
  }): Promise<VotingPowerAtHeightResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      voting_power_at_height: {
        address,
        height
      }
    });
  };
  slashableTokenNumForVotingOnProposal = async ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      slashable_token_num_for_voting_on_proposal: {
        proposal_id: proposalId,
        round_id: roundId,
        tranche_id: trancheId
      }
    });
  };
  ownerOf = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  approval = async ({
    includeExpired,
    spender,
    tokenId
  }: {
    includeExpired?: boolean;
    spender: string;
    tokenId: string;
  }): Promise<ApprovalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      approval: {
        include_expired: includeExpired,
        spender,
        token_id: tokenId
      }
    });
  };
  approvals = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<ApprovalsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      approvals: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  allOperators = async ({
    includeExpired,
    limit,
    owner,
    startAfter
  }: {
    includeExpired?: boolean;
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<OperatorsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_operators: {
        include_expired: includeExpired,
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  collectionInfo = async (): Promise<CollectionInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      collection_info: {}
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: string;
  }): Promise<NftInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  allNftInfo = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: string;
  }): Promise<AllNftInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_nft_info: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        start_after: startAfter
      }
    });
  };
  simulateDtokenAmounts = async ({
    address,
    lockIds
  }: {
    address: string;
    lockIds: number[];
  }): Promise<DtokenAmountsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      simulate_dtoken_amounts: {
        address,
        lock_ids: lockIds
      }
    });
  };
}
export interface HydroBaseInterface extends HydroBaseReadOnlyInterface {
  contractAddress: string;
  sender: string;
  lockTokens: ({
    lockDuration,
    proof
  }: {
    lockDuration: number;
    proof?: LockTokensProof;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  refreshLockDuration: ({
    lockDuration,
    lockIds
  }: {
    lockDuration: number;
    lockIds: number[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  splitLock: ({
    amount,
    lockId
  }: {
    amount: Uint128;
    lockId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  mergeLocks: ({
    lockIds
  }: {
    lockIds: number[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  unlockTokens: ({
    lockIds
  }: {
    lockIds?: number[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  createProposal: ({
    deploymentDuration,
    description,
    minimumAtomLiquidityRequest,
    roundId,
    title,
    trancheId
  }: {
    deploymentDuration: number;
    description: string;
    minimumAtomLiquidityRequest: Uint128;
    roundId?: number;
    title: string;
    trancheId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  vote: ({
    proposalsVotes,
    trancheId
  }: {
    proposalsVotes: ProposalToLockups[];
    trancheId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  unvote: ({
    lockIds,
    trancheId
  }: {
    lockIds: number[];
    trancheId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  addAccountToWhitelist: ({
    address
  }: {
    address: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  removeAccountFromWhitelist: ({
    address
  }: {
    address: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    config
  }: {
    config: UpdateConfigData;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  deleteConfigs: ({
    timestamps
  }: {
    timestamps: Timestamp[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  pause: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  addTranche: ({
    tranche
  }: {
    tranche: TrancheInfo;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  editTranche: ({
    trancheId,
    trancheMetadata,
    trancheName
  }: {
    trancheId: number;
    trancheMetadata?: string;
    trancheName?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  addLiquidityDeployment: ({
    deployedFunds,
    destinations,
    fundsBeforeDeployment,
    proposalId,
    remainingRounds,
    roundId,
    totalRounds,
    trancheId
  }: {
    deployedFunds: Coin[];
    destinations: string[];
    fundsBeforeDeployment: Coin[];
    proposalId: number;
    remainingRounds: number;
    roundId: number;
    totalRounds: number;
    trancheId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  removeLiquidityDeployment: ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateTokenGroupsRatios: ({
    changes
  }: {
    changes: TokenGroupRatioChange[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  addTokenInfoProvider: ({
    tokenInfoProvider
  }: {
    tokenInfoProvider: TokenInfoProviderInstantiateMsg;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  removeTokenInfoProvider: ({
    providerId
  }: {
    providerId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  setGatekeeper: ({
    gatekeeperAddr
  }: {
    gatekeeperAddr?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  transferNft: ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  sendNft: ({
    contract,
    msg,
    tokenId
  }: {
    contract: string;
    msg: Binary;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  approve: ({
    expires,
    spender,
    tokenId
  }: {
    expires?: Expiration;
    spender: string;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  revoke: ({
    spender,
    tokenId
  }: {
    spender: string;
    tokenId: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  approveAll: ({
    expires,
    operator
  }: {
    expires?: Expiration;
    operator: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  revokeAll: ({
    operator
  }: {
    operator: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  setDropTokenInfo: ({
    coreAddress,
    dTokenDenom,
    puppeteerAddress
  }: {
    coreAddress: string;
    dTokenDenom: string;
    puppeteerAddress: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  convertLockupToDtoken: ({
    lockIds
  }: {
    lockIds: number[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  slashProposalVoters: ({
    limit,
    proposalId,
    roundId,
    slashPercent,
    startFrom,
    trancheId
  }: {
    limit: number;
    proposalId: number;
    roundId: number;
    slashPercent: Decimal;
    startFrom: number;
    trancheId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  buyoutPendingSlash: ({
    lockId
  }: {
    lockId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class HydroBaseClient extends HydroBaseQueryClient implements HydroBaseInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.lockTokens = this.lockTokens.bind(this);
    this.refreshLockDuration = this.refreshLockDuration.bind(this);
    this.splitLock = this.splitLock.bind(this);
    this.mergeLocks = this.mergeLocks.bind(this);
    this.unlockTokens = this.unlockTokens.bind(this);
    this.createProposal = this.createProposal.bind(this);
    this.vote = this.vote.bind(this);
    this.unvote = this.unvote.bind(this);
    this.addAccountToWhitelist = this.addAccountToWhitelist.bind(this);
    this.removeAccountFromWhitelist = this.removeAccountFromWhitelist.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.deleteConfigs = this.deleteConfigs.bind(this);
    this.pause = this.pause.bind(this);
    this.addTranche = this.addTranche.bind(this);
    this.editTranche = this.editTranche.bind(this);
    this.addLiquidityDeployment = this.addLiquidityDeployment.bind(this);
    this.removeLiquidityDeployment = this.removeLiquidityDeployment.bind(this);
    this.updateTokenGroupsRatios = this.updateTokenGroupsRatios.bind(this);
    this.addTokenInfoProvider = this.addTokenInfoProvider.bind(this);
    this.removeTokenInfoProvider = this.removeTokenInfoProvider.bind(this);
    this.setGatekeeper = this.setGatekeeper.bind(this);
    this.transferNft = this.transferNft.bind(this);
    this.sendNft = this.sendNft.bind(this);
    this.approve = this.approve.bind(this);
    this.revoke = this.revoke.bind(this);
    this.approveAll = this.approveAll.bind(this);
    this.revokeAll = this.revokeAll.bind(this);
    this.setDropTokenInfo = this.setDropTokenInfo.bind(this);
    this.convertLockupToDtoken = this.convertLockupToDtoken.bind(this);
    this.slashProposalVoters = this.slashProposalVoters.bind(this);
    this.buyoutPendingSlash = this.buyoutPendingSlash.bind(this);
  }
  lockTokens = async ({
    lockDuration,
    proof
  }: {
    lockDuration: number;
    proof?: LockTokensProof;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      lock_tokens: {
        lock_duration: lockDuration,
        proof
      }
    }, fee_, memo_, funds_);
  };
  refreshLockDuration = async ({
    lockDuration,
    lockIds
  }: {
    lockDuration: number;
    lockIds: number[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      refresh_lock_duration: {
        lock_duration: lockDuration,
        lock_ids: lockIds
      }
    }, fee_, memo_, funds_);
  };
  splitLock = async ({
    amount,
    lockId
  }: {
    amount: Uint128;
    lockId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      split_lock: {
        amount,
        lock_id: lockId
      }
    }, fee_, memo_, funds_);
  };
  mergeLocks = async ({
    lockIds
  }: {
    lockIds: number[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      merge_locks: {
        lock_ids: lockIds
      }
    }, fee_, memo_, funds_);
  };
  unlockTokens = async ({
    lockIds
  }: {
    lockIds?: number[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unlock_tokens: {
        lock_ids: lockIds
      }
    }, fee_, memo_, funds_);
  };
  createProposal = async ({
    deploymentDuration,
    description,
    minimumAtomLiquidityRequest,
    roundId,
    title,
    trancheId
  }: {
    deploymentDuration: number;
    description: string;
    minimumAtomLiquidityRequest: Uint128;
    roundId?: number;
    title: string;
    trancheId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_proposal: {
        deployment_duration: deploymentDuration,
        description,
        minimum_atom_liquidity_request: minimumAtomLiquidityRequest,
        round_id: roundId,
        title,
        tranche_id: trancheId
      }
    }, fee_, memo_, funds_);
  };
  vote = async ({
    proposalsVotes,
    trancheId
  }: {
    proposalsVotes: ProposalToLockups[];
    trancheId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      vote: {
        proposals_votes: proposalsVotes,
        tranche_id: trancheId
      }
    }, fee_, memo_, funds_);
  };
  unvote = async ({
    lockIds,
    trancheId
  }: {
    lockIds: number[];
    trancheId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unvote: {
        lock_ids: lockIds,
        tranche_id: trancheId
      }
    }, fee_, memo_, funds_);
  };
  addAccountToWhitelist = async ({
    address
  }: {
    address: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_account_to_whitelist: {
        address
      }
    }, fee_, memo_, funds_);
  };
  removeAccountFromWhitelist = async ({
    address
  }: {
    address: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_account_from_whitelist: {
        address
      }
    }, fee_, memo_, funds_);
  };
  updateConfig = async ({
    config
  }: {
    config: UpdateConfigData;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        config
      }
    }, fee_, memo_, funds_);
  };
  deleteConfigs = async ({
    timestamps
  }: {
    timestamps: Timestamp[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delete_configs: {
        timestamps
      }
    }, fee_, memo_, funds_);
  };
  pause = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause: {}
    }, fee_, memo_, funds_);
  };
  addTranche = async ({
    tranche
  }: {
    tranche: TrancheInfo;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_tranche: {
        tranche
      }
    }, fee_, memo_, funds_);
  };
  editTranche = async ({
    trancheId,
    trancheMetadata,
    trancheName
  }: {
    trancheId: number;
    trancheMetadata?: string;
    trancheName?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_tranche: {
        tranche_id: trancheId,
        tranche_metadata: trancheMetadata,
        tranche_name: trancheName
      }
    }, fee_, memo_, funds_);
  };
  addLiquidityDeployment = async ({
    deployedFunds,
    destinations,
    fundsBeforeDeployment,
    proposalId,
    remainingRounds,
    roundId,
    totalRounds,
    trancheId
  }: {
    deployedFunds: Coin[];
    destinations: string[];
    fundsBeforeDeployment: Coin[];
    proposalId: number;
    remainingRounds: number;
    roundId: number;
    totalRounds: number;
    trancheId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_liquidity_deployment: {
        deployed_funds: deployedFunds,
        destinations,
        funds_before_deployment: fundsBeforeDeployment,
        proposal_id: proposalId,
        remaining_rounds: remainingRounds,
        round_id: roundId,
        total_rounds: totalRounds,
        tranche_id: trancheId
      }
    }, fee_, memo_, funds_);
  };
  removeLiquidityDeployment = async ({
    proposalId,
    roundId,
    trancheId
  }: {
    proposalId: number;
    roundId: number;
    trancheId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_liquidity_deployment: {
        proposal_id: proposalId,
        round_id: roundId,
        tranche_id: trancheId
      }
    }, fee_, memo_, funds_);
  };
  updateTokenGroupsRatios = async ({
    changes
  }: {
    changes: TokenGroupRatioChange[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_token_groups_ratios: {
        changes
      }
    }, fee_, memo_, funds_);
  };
  addTokenInfoProvider = async ({
    tokenInfoProvider
  }: {
    tokenInfoProvider: TokenInfoProviderInstantiateMsg;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_token_info_provider: {
        token_info_provider: tokenInfoProvider
      }
    }, fee_, memo_, funds_);
  };
  removeTokenInfoProvider = async ({
    providerId
  }: {
    providerId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_token_info_provider: {
        provider_id: providerId
      }
    }, fee_, memo_, funds_);
  };
  setGatekeeper = async ({
    gatekeeperAddr
  }: {
    gatekeeperAddr?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_gatekeeper: {
        gatekeeper_addr: gatekeeperAddr
      }
    }, fee_, memo_, funds_);
  };
  transferNft = async ({
    recipient,
    tokenId
  }: {
    recipient: string;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_nft: {
        recipient,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  sendNft = async ({
    contract,
    msg,
    tokenId
  }: {
    contract: string;
    msg: Binary;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_nft: {
        contract,
        msg,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  approve = async ({
    expires,
    spender,
    tokenId
  }: {
    expires?: Expiration;
    spender: string;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      approve: {
        expires,
        spender,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  revoke = async ({
    spender,
    tokenId
  }: {
    spender: string;
    tokenId: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke: {
        spender,
        token_id: tokenId
      }
    }, fee_, memo_, funds_);
  };
  approveAll = async ({
    expires,
    operator
  }: {
    expires?: Expiration;
    operator: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      approve_all: {
        expires,
        operator
      }
    }, fee_, memo_, funds_);
  };
  revokeAll = async ({
    operator
  }: {
    operator: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_all: {
        operator
      }
    }, fee_, memo_, funds_);
  };
  setDropTokenInfo = async ({
    coreAddress,
    dTokenDenom,
    puppeteerAddress
  }: {
    coreAddress: string;
    dTokenDenom: string;
    puppeteerAddress: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_drop_token_info: {
        core_address: coreAddress,
        d_token_denom: dTokenDenom,
        puppeteer_address: puppeteerAddress
      }
    }, fee_, memo_, funds_);
  };
  convertLockupToDtoken = async ({
    lockIds
  }: {
    lockIds: number[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      convert_lockup_to_dtoken: {
        lock_ids: lockIds
      }
    }, fee_, memo_, funds_);
  };
  slashProposalVoters = async ({
    limit,
    proposalId,
    roundId,
    slashPercent,
    startFrom,
    trancheId
  }: {
    limit: number;
    proposalId: number;
    roundId: number;
    slashPercent: Decimal;
    startFrom: number;
    trancheId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      slash_proposal_voters: {
        limit,
        proposal_id: proposalId,
        round_id: roundId,
        slash_percent: slashPercent,
        start_from: startFrom,
        tranche_id: trancheId
      }
    }, fee_, memo_, funds_);
  };
  buyoutPendingSlash = async ({
    lockId
  }: {
    lockId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      buyout_pending_slash: {
        lock_id: lockId
      }
    }, fee_, memo_, funds_);
  };
}