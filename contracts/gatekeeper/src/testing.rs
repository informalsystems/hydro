use bech32::{encode, Bech32, Hrp};
use cosmwasm_std::{
    testing::{mock_dependencies, mock_env, MockApi, MockQuerier, MockStorage},
    to_json_binary, Binary, Coin, Empty, Env, MessageInfo, OwnedDeps, Timestamp, Uint128,
};
use interface::gatekeeper::ExecuteLockTokensMsg;
use k256::ecdsa::{signature::Signer, Signature, SigningKey};
use ripemd::Ripemd160;
use sha2::{Digest, Sha256};

use crate::{
    contract::{execute, get_epoch_start_for_stage_id, instantiate, query_current_stage},
    msg::{ExecuteMsg, InstantiateMsg},
    utils::{ClaimMsg, CosmosSignature},
};
use interface::gatekeeper::SignatureInfo;

// Randomly generated byte arrays used to build private/public key pairs in one of the tests
const PRIVATE_KEY_BYTES_1: &[u8] = &[
    2, 137, 4, 147, 77, 14, 18, 96, 147, 192, 131, 155, 7, 155, 135, 245, 93, 9, 15, 185, 237, 110,
    50, 252, 111, 47, 153, 23, 65, 227, 64, 77,
];
const PRIVATE_KEY_BYTES_2: &[u8] = &[
    40, 225, 77, 212, 23, 67, 54, 122, 33, 164, 239, 80, 199, 116, 119, 121, 175, 215, 222, 117,
    75, 95, 155, 102, 69, 138, 151, 205, 104, 92, 59, 191,
];

pub fn get_message_info(api: &MockApi, sender: &str, funds: &[Coin]) -> MessageInfo {
    MessageInfo {
        sender: api.addr_make(sender),
        funds: funds.to_vec(),
    }
}

// This test verifies that:
//  1) Only admins can register new stages
//  2) Stages are registered successfully and taken into account correctly as the block time progresses
//  3) Stages cannot be registered for the past timestamps
//  4) A new stage can be registered only at timestamps that are later than all of the already existing stages,
//     except for the latest existing stage where
//  5) A new stage can be registered at identical timestamp as the latest registered stage
#[test]
fn register_stage_test() {
    let (mut deps, mut env) = (mock_dependencies(), mock_env());
    env.block.time = Timestamp::from_nanos(1744012800000000000); // April 7, 2025 8:00:00 AM UTC

    let hydro_info = get_message_info(&deps.api, "hydro", &[]);
    let admin_info = get_message_info(&deps.api, "addr0000", &[]);
    let non_admin_info = get_message_info(&deps.api, "addr0002", &[]);

    let init_msg = InstantiateMsg {
        admins: vec![admin_info.sender.to_string()],
    };

    let res = instantiate(deps.as_mut(), env.clone(), hydro_info, init_msg.clone());
    assert!(res.is_ok());

    let msg = ExecuteMsg::RegisterStage {
        merkle_root: String::from(""),
        activate_at: env.block.time.minus_nanos(10),
        start_new_epoch: false,
        hrp: None,
    };

    // Try to register new stage with non-admin sender
    let res = execute(deps.as_mut(), env.clone(), non_admin_info, msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains("Unauthorized"));

    // Try to register new stage in the past
    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res
        .unwrap_err()
        .to_string()
        .contains("Cannot register new stage for the timestamp in past."));

    // Register first stage
    let first_stage_id = 0;
    let mut activate_at = env.block.time.plus_hours(1);
    let mut merkle_root = String::from("asd");
    let mut start_new_epoch = false;
    let mut hrp: Option<String> = None;

    let msg = ExecuteMsg::RegisterStage {
        activate_at,
        merkle_root: merkle_root.clone(),
        // new epoch should be started regardless of this flag, since this will be the first registered stage
        start_new_epoch,
        hrp: hrp.clone(),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to verify that the correct stage is returned by the query
    env.block.time = env.block.time.plus_hours(1);

    let current_stage = query_current_stage(&deps.as_ref(), &env).unwrap().stage;
    assert_eq!(current_stage.stage_id, first_stage_id);
    assert_eq!(current_stage.activate_at, activate_at);
    assert_eq!(current_stage.merkle_root, merkle_root.clone());
    assert_eq!(current_stage.hrp, hrp.clone());

    // Register second stage
    let second_stage_id = 1;
    activate_at = activate_at.plus_hours(1);
    merkle_root = String::from("fgh");
    start_new_epoch = false;
    hrp = None;

    let msg = ExecuteMsg::RegisterStage {
        activate_at,
        merkle_root: merkle_root.clone(),
        start_new_epoch,
        hrp: hrp.clone(),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to verify that the correct stage is returned by the query
    env.block.time = env.block.time.plus_hours(1);

    let current_stage = query_current_stage(&deps.as_ref(), &env).unwrap().stage;
    assert_eq!(current_stage.stage_id, second_stage_id);
    assert_eq!(current_stage.activate_at, activate_at);
    assert_eq!(current_stage.merkle_root, merkle_root.clone());
    assert_eq!(current_stage.hrp, hrp.clone());

    // Assert that the first two stages belong to the first (and currently only) epoch
    let epoch_start_stage = get_epoch_start_for_stage_id(&deps.as_ref(), first_stage_id).unwrap();
    assert_eq!(epoch_start_stage, first_stage_id);
    let epoch_start_stage = get_epoch_start_for_stage_id(&deps.as_ref(), second_stage_id).unwrap();
    assert_eq!(epoch_start_stage, first_stage_id);

    // Register third stage and mark it as a new epoch start
    let third_stage_id = 2;
    activate_at = activate_at.plus_hours(1);
    merkle_root = String::from("jkl");
    start_new_epoch = true;
    hrp = None;

    let msg = ExecuteMsg::RegisterStage {
        activate_at,
        merkle_root: merkle_root.clone(),
        start_new_epoch,
        hrp: hrp.clone(),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to verify that the correct stage is returned by the query
    env.block.time = env.block.time.plus_hours(1);

    let current_stage = query_current_stage(&deps.as_ref(), &env).unwrap().stage;
    assert_eq!(current_stage.stage_id, third_stage_id);
    assert_eq!(current_stage.activate_at, activate_at);
    assert_eq!(current_stage.merkle_root, merkle_root.clone());
    assert_eq!(current_stage.hrp, hrp.clone());

    // Assert that the first two stages still belong to the first epoch
    let epoch_start_stage = get_epoch_start_for_stage_id(&deps.as_ref(), first_stage_id).unwrap();
    assert_eq!(epoch_start_stage, first_stage_id);
    let epoch_start_stage = get_epoch_start_for_stage_id(&deps.as_ref(), second_stage_id).unwrap();
    assert_eq!(epoch_start_stage, first_stage_id);

    // But the third stage belongs to a new epoch
    let epoch_start_stage = get_epoch_start_for_stage_id(&deps.as_ref(), third_stage_id).unwrap();
    assert_eq!(epoch_start_stage, third_stage_id);

    // Register fourth stage
    activate_at = activate_at.plus_hours(1);
    merkle_root = String::from("zxc");
    start_new_epoch = true;
    hrp = None;

    let msg = ExecuteMsg::RegisterStage {
        activate_at,
        merkle_root: merkle_root.clone(),
        start_new_epoch,
        hrp: hrp.clone(),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Register fifth stage at the same timestamp as the fourth stage
    let fifth_stage_id = 4;
    merkle_root = String::from("vbn");
    start_new_epoch = true;
    hrp = None;

    let msg = ExecuteMsg::RegisterStage {
        activate_at,
        merkle_root: merkle_root.clone(),
        start_new_epoch,
        hrp: hrp.clone(),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Verify that the new stage can not be registered at a timestamp before already existing stage
    let msg = ExecuteMsg::RegisterStage {
        activate_at: activate_at.minus_minutes(1),
        merkle_root: merkle_root.clone(),
        start_new_epoch,
        hrp: hrp.clone(),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res
        .unwrap_err()
        .to_string()
        .contains("Cannot register new stage at a timestamp earlier than already existing stage."));

    // Advance the chain to verify that the correct stage is returned by the query
    env.block.time = env.block.time.plus_hours(1);

    let current_stage = query_current_stage(&deps.as_ref(), &env).unwrap().stage;
    assert_eq!(current_stage.stage_id, fifth_stage_id);
    assert_eq!(current_stage.activate_at, activate_at);
    assert_eq!(current_stage.merkle_root, merkle_root.clone());
    assert_eq!(current_stage.hrp, hrp.clone());
}

// This test verifies that:
//  1) Locking of tokens on Gatekeeper can be called only by the Hydro smart contract
//  2) Users can lock tokens if they provide valid proofs and try to lock the amount that
//     is smaller than or equal to the amount they are eligible for
//  3) Lock cannot be performed if the wrong proofs are provided
//  4) User cannot lock more tokens than it is allowed to, whether through a single or multiple attempts
// Merkle root is built using https://github.com/CosmWasm/cw-tokens/tree/main/contracts/cw20-merkle-airdrop/helpers
// Addresses were built using MockApi.addr_make() by using "addr0001" and "addr0002" as input values.
#[test]
fn lock_tokens_basic_test() {
    let (mut deps, mut env) = (mock_dependencies(), mock_env());
    env.block.time = Timestamp::from_nanos(1744012800000000000); // April 7, 2025 8:00:00 AM UTC

    let hydro_info = get_message_info(&deps.api, "hydro", &[]);
    let admin_info = get_message_info(&deps.api, "addr0000", &[]);

    let init_msg = InstantiateMsg {
        admins: vec![admin_info.sender.to_string()],
    };

    let res = instantiate(
        deps.as_mut(),
        env.clone(),
        hydro_info.clone(),
        init_msg.clone(),
    );
    assert!(res.is_ok());

    // Input JSON:
    // [
    //   { "address": "cosmwasm1wtqa75mkgwgncx8v4dep5aygmnq7gspaufggc5ev3u68et43qxmsqy5haw", "amount": "1100"},
    //   { "address": "cosmwasm1g807u64s6uvk3daw4k4h778h850put0qdny3llp3xn43y5dar0hqfdcpt4", "amount": "700"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "0500bc85b0166645055665557eb7c7f722b8feb255e2029f74d37720258de88e",
        ),
        start_new_epoch: true,
        hrp: None,
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the first stage
    env.block.time = env.block.time.plus_hours(1);

    let user1_info = get_message_info(&deps.api, "addr0001", &[]);
    let user1_maximum_amount = Uint128::new(1100);
    let user1_valid_proof = "4ca1257212c9d742b8ece318aaaa9db26d603f1c3f9e83592f2d2c87d8818b2d";
    let user1_invalid_proof = "8ca1257212c9d742b8ece318aaaa9db26d603f1c3f9e83592f2d2c87d8818b2d";

    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user1_info.sender.to_string(),
        amount_to_lock: user1_maximum_amount,
        maximum_amount: user1_maximum_amount,
        proof: vec![user1_invalid_proof.to_string()],
        sig_info: None,
    });

    // Try to lock tokens directly
    let res = execute(deps.as_mut(), env.clone(), user1_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains("Unauthorized"));

    // Try to lock by providing wrong proofs
    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res
        .unwrap_err()
        .to_string()
        .contains("Failed to verify provided proofs against the current stage root."));

    // Try to lock more than allowed by providing valid proofs
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user1_info.sender.to_string(),
        amount_to_lock: user1_maximum_amount + Uint128::one(),
        maximum_amount: user1_maximum_amount,
        proof: vec![user1_valid_proof.to_string()],
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "User cannot lock {} tokens. Currently locked: {}. Maximum allowed to lock: {}.",
        1101, 0, 1100
    )));

    // Lock only part of what is allowed for the user
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user1_info.sender.to_string(),
        amount_to_lock: Uint128::new(600),
        maximum_amount: user1_maximum_amount,
        proof: vec![user1_valid_proof.to_string()],
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Lock the rest of what is allowed for the user
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user1_info.sender.to_string(),
        amount_to_lock: Uint128::new(500),
        maximum_amount: user1_maximum_amount,
        proof: vec![user1_valid_proof.to_string()],
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Try to lock again more that it should be allowed
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user1_info.sender.to_string(),
        amount_to_lock: Uint128::one(),
        maximum_amount: user1_maximum_amount,
        proof: vec![user1_valid_proof.to_string()],
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "User cannot lock {} tokens. Currently locked: {}. Maximum allowed to lock: {}.",
        1, 1100, 1100
    )));

    // Verify that the second user can lock the maximum amout it is eligible for
    let user2_info = get_message_info(&deps.api, "addr0002", &[]);
    let user2_maximum_amount = Uint128::new(700);
    let user2_valid_proof = "cc6069f1650e236cf30ac38a6c81bfc5f609b814b6f36dac454eecd74b2890bf";

    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user2_info.sender.to_string(),
        amount_to_lock: user2_maximum_amount,
        maximum_amount: user2_maximum_amount,
        proof: vec![user2_valid_proof.to_string()],
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Then verify it can not lock more than that
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user2_info.sender.to_string(),
        amount_to_lock: Uint128::one(),
        maximum_amount: user2_maximum_amount,
        proof: vec![user2_valid_proof.to_string()],
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "User cannot lock {} tokens. Currently locked: {}. Maximum allowed to lock: {}.",
        1, 700, 700,
    )));
}

// This test verifies that:
//  1) Gatekeeper smart contract enforces the maximum number of tokens that can be locked per user
//  2) If the next stage of the same epoch increases maximum allowed to be locked, user will be able to
//     lock the diff between the amount it locked in previous stage(s) and the maximum allowed in current stage
//  3) If the next stage of the same epoch decreases maximum allowed to be locked, and user already locked
//     more than the maximum allowed in next stage, it will not be allowed to lock any more tokens
//  4) If user didn't lock any tokens in previous N stages, and wants to lock some tokens while the current stage
//     is active, it will be allowed to lock only at most the given stage allows
//  5) Already locked number of tokens counter gets reset when a new epoch starts
// Merkle roots are built using https://github.com/CosmWasm/cw-tokens/tree/main/contracts/cw20-merkle-airdrop/helpers
// Addresses were built using MockApi.addr_make() by providing "addr0001" and "addr0002" as input values.
#[test]
fn lock_tokens_stage_epoch_caps_test() {
    let (mut deps, mut env) = (mock_dependencies(), mock_env());
    env.block.time = Timestamp::from_nanos(1744012800000000000); // April 7, 2025 8:00:00 AM UTC

    let hydro_info = get_message_info(&deps.api, "hydro", &[]);
    let admin_info = get_message_info(&deps.api, "addr0000", &[]);

    let init_msg = InstantiateMsg {
        admins: vec![admin_info.sender.to_string()],
    };

    let res = instantiate(
        deps.as_mut(),
        env.clone(),
        hydro_info.clone(),
        init_msg.clone(),
    );
    assert!(res.is_ok());

    // Input JSON:
    // [
    //   { "address": "cosmwasm1wtqa75mkgwgncx8v4dep5aygmnq7gspaufggc5ev3u68et43qxmsqy5haw", "amount": "1100"},
    //   { "address": "cosmwasm1g807u64s6uvk3daw4k4h778h850put0qdny3llp3xn43y5dar0hqfdcpt4", "amount": "700"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "0500bc85b0166645055665557eb7c7f722b8feb255e2029f74d37720258de88e",
        ),
        start_new_epoch: true,
        hrp: None,
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the first stage
    env.block.time = env.block.time.plus_hours(1);

    let user1_info = get_message_info(&deps.api, "addr0001", &[]);
    let user2_info = get_message_info(&deps.api, "addr0002", &[]);

    let already_locked_amount = Uint128::zero();
    let amount_to_lock = Uint128::new(1100);
    let stage_allowed_to_lock = Uint128::new(1100);
    let proofs =
        vec!["4ca1257212c9d742b8ece318aaaa9db26d603f1c3f9e83592f2d2c87d8818b2d".to_string()];

    lock_maximum_amount(
        &mut deps,
        &env,
        &hydro_info,
        &user1_info,
        already_locked_amount,
        amount_to_lock,
        stage_allowed_to_lock,
        proofs,
    );

    // Input JSON:
    // [
    //   { "address": "cosmwasm1wtqa75mkgwgncx8v4dep5aygmnq7gspaufggc5ev3u68et43qxmsqy5haw", "amount": "2200"},
    //   { "address": "cosmwasm1g807u64s6uvk3daw4k4h778h850put0qdny3llp3xn43y5dar0hqfdcpt4", "amount": "1500"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "8c1fa49cedae2487f530672f9c95e46ea276b03d1805147f403bcad243173d40",
        ),
        start_new_epoch: false,
        hrp: None,
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the second stage
    env.block.time = env.block.time.plus_hours(1);

    let already_locked_amount = Uint128::new(1100);
    let amount_to_lock = Uint128::new(1100);
    let stage_allowed_to_lock = Uint128::new(2200);
    let proofs =
        vec!["49a98d951d2ba2b560e2810ee9beecbf979dd51ecd5c16df7e7fbe67af5e2ed1".to_string()];

    lock_maximum_amount(
        &mut deps,
        &env,
        &hydro_info,
        &user1_info,
        already_locked_amount,
        amount_to_lock,
        stage_allowed_to_lock,
        proofs,
    );

    // For the third stage, reduce maximum allowed for locking and verify that user cannot lock any additional tokens.
    // Input JSON:
    // [
    //   { "address": "cosmwasm1wtqa75mkgwgncx8v4dep5aygmnq7gspaufggc5ev3u68et43qxmsqy5haw", "amount": "300"},
    //   { "address": "cosmwasm1g807u64s6uvk3daw4k4h778h850put0qdny3llp3xn43y5dar0hqfdcpt4", "amount": "300"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "91dff6911f436b68ebdcb0b08ee0f67abf9daf346723ee262b5ec3a9ad862ec1",
        ),
        start_new_epoch: false,
        hrp: None,
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the third stage
    env.block.time = env.block.time.plus_hours(1);

    let already_locked_amount = Uint128::new(2200);
    let stage_allowed_to_lock = Uint128::new(300);
    let proofs =
        vec!["4fa659576eb72a5a90818bccd21571f5c7d6ccaaecaf3e4cd9b8befe6e2e2f0c".to_string()];

    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user1_info.sender.to_string(),
        amount_to_lock: Uint128::one(),
        maximum_amount: stage_allowed_to_lock,
        proof: proofs.clone(),
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "User cannot lock {} tokens. Currently locked: {}. Maximum allowed to lock: {}.",
        Uint128::one(),
        already_locked_amount,
        stage_allowed_to_lock,
    )));

    // Verify that the second user can lock at most 300 tokens, as defined by the current stage, even though
    // this user had a chance to lock more tokens in earlier stages, but didn't use that chance.
    let already_locked_amount = Uint128::new(0);
    let amount_to_lock = Uint128::new(300);
    let stage_allowed_to_lock = Uint128::new(300);
    let proofs =
        vec!["7e11d21dc0e0691b6b427c3b4ffd4bfde25650946298ce86fabc3abc510801c4".to_string()];

    lock_maximum_amount(
        &mut deps,
        &env,
        &hydro_info,
        &user2_info,
        already_locked_amount,
        amount_to_lock,
        stage_allowed_to_lock,
        proofs,
    );

    // For the fourth stage, start a new epoch and use smaller values to verify that the counter
    // has been reset and that the user can lock more tokens.
    // Input JSON:
    // [
    //   { "address": "cosmwasm1wtqa75mkgwgncx8v4dep5aygmnq7gspaufggc5ev3u68et43qxmsqy5haw", "amount": "150"},
    //   { "address": "cosmwasm1g807u64s6uvk3daw4k4h778h850put0qdny3llp3xn43y5dar0hqfdcpt4", "amount": "200"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "564af74ccac194c294f7257cafc4ff11300f2875af5bbd4fea6b1afaf2f87f6c",
        ),
        start_new_epoch: true,
        hrp: None,
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the fourth stage
    env.block.time = env.block.time.plus_hours(1);

    let already_locked_amount = Uint128::new(0);
    let amount_to_lock = Uint128::new(150);
    let stage_allowed_to_lock = Uint128::new(150);
    let proofs =
        vec!["f90a0c65c9548a506ec3da12baa39a4b9ffa2cc6004599803a5b535f0cc03e9b".to_string()];

    lock_maximum_amount(
        &mut deps,
        &env,
        &hydro_info,
        &user1_info,
        already_locked_amount,
        amount_to_lock,
        stage_allowed_to_lock,
        proofs,
    );

    // In the fifth stage verify that maximum allowed counter keeps increasing and that the user can lock
    // only the diff between what it already locked and the maximum number specified by the fifth stage.
    // Input JSON:
    // [
    //   { "address": "cosmwasm1wtqa75mkgwgncx8v4dep5aygmnq7gspaufggc5ev3u68et43qxmsqy5haw", "amount": "500"},
    //   { "address": "cosmwasm1g807u64s6uvk3daw4k4h778h850put0qdny3llp3xn43y5dar0hqfdcpt4", "amount": "400"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "5fbe01c1903bf3bc40ef7e8ec24a28cc87b81ca49d958ee4b4b00dbb260db2da",
        ),
        start_new_epoch: false,
        hrp: None,
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the fifth stage
    env.block.time = env.block.time.plus_hours(1);

    let already_locked_amount = Uint128::new(150);
    let amount_to_lock = Uint128::new(350);
    let stage_allowed_to_lock = Uint128::new(500);
    let proofs =
        vec!["348f74c9a98138f88784fda50e07514f1ba70646c8047f9b8fcc6fdb725b9b36".to_string()];

    lock_maximum_amount(
        &mut deps,
        &env,
        &hydro_info,
        &user1_info,
        already_locked_amount,
        amount_to_lock,
        stage_allowed_to_lock,
        proofs,
    );
}

#[allow(clippy::too_many_arguments)]
fn lock_maximum_amount(
    deps: &mut OwnedDeps<MockStorage, MockApi, MockQuerier, Empty>,
    env: &Env,
    hydro_info: &MessageInfo,
    user_info: &MessageInfo,
    already_locked_amount: Uint128,
    amount_to_lock: Uint128,
    stage_allowed_to_lock: Uint128,
    proofs: Vec<String>,
) {
    // First try to lock slightly more than the maximum allowed for user in current stage
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user_info.sender.to_string(),
        amount_to_lock: amount_to_lock + Uint128::one(),
        maximum_amount: stage_allowed_to_lock,
        proof: proofs.clone(),
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "User cannot lock {} tokens. Currently locked: {}. Maximum allowed to lock: {}.",
        amount_to_lock + Uint128::one(),
        already_locked_amount,
        stage_allowed_to_lock,
    )));

    // Then lock the maximum allowed for user in current stage
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: user_info.sender.to_string(),
        amount_to_lock,
        maximum_amount: stage_allowed_to_lock,
        proof: proofs,
        sig_info: None,
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());
}

// This test verifies that users can lock tokens in those stages that have merkle trees built from
// JSON files containing addresses from other chains than Neutron (e.g. Cosmos Hub, Celestia, etc.)
#[test]
fn lock_tokens_external_addresses_test() {
    let (mut deps, mut env) = (mock_dependencies(), mock_env());
    env.block.time = Timestamp::from_nanos(1744012800000000000); // April 7, 2025 8:00:00 AM UTC

    let hydro_info = get_message_info(&deps.api, "hydro", &[]);
    let admin_info = get_message_info(&deps.api, "addr0000", &[]);

    let init_msg = InstantiateMsg {
        admins: vec![admin_info.sender.to_string()],
    };

    let res = instantiate(
        deps.as_mut(),
        env.clone(),
        hydro_info.clone(),
        init_msg.clone(),
    );
    assert!(res.is_ok());

    // These addresses are generated from PRIVATE_KEY_BYTES_1 and PRIVATE_KEY_BYTES_2
    // Input JSON:
    // [
    //   { "address": "celestia18jg6zhw00989l578vnrzvz7g6en9kcwfceg2ph", "amount": "70"},
    //   { "address": "celestia1jhln90cx8297qjkvmq6f3adxzav0uhpaxqfutk", "amount": "30"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "1eb6207d55995d81d0c190d7ff85e16273ae9044de17b34f69f6b08d02639e0b",
        ),
        start_new_epoch: true,
        hrp: Some(String::from("celestia")),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the first stage
    env.block.time = env.block.time.plus_hours(1);

    let (priv_key1, pub_key1) = build_keys(PRIVATE_KEY_BYTES_1);
    let address_to_sign1 = public_key_to_address(&pub_key1, "cosmwasm");
    let user1_valid_proof = "1a3a5e206cfe96d0c22b29beaeb3d51f9ed89906659d56591baac98581800f5a";

    let (priv_key2, pub_key2) = build_keys(PRIVATE_KEY_BYTES_2);
    let address_to_sign2 = public_key_to_address(&pub_key2, "cosmwasm");
    let user2_valid_proof = "b42cf8c3b4b53941c1b3c641aa7bf4f9f7253c913876909ad293133ebc755e51";

    // Try to lock tokens by providing valid proof, but signing a different address
    // than the one used in 'user_address' msg field
    let sig_info = sign_message(&priv_key1, &pub_key1, &address_to_sign2);
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: address_to_sign1.clone(),
        amount_to_lock: Uint128::new(70),
        maximum_amount: Uint128::new(70),
        proof: vec![user1_valid_proof.to_string()],
        sig_info: Some(sig_info),
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "Signature verification failed. Signed address ({}) doesn't match the expected one ({}).",
        address_to_sign2, address_to_sign1
    )));

    // Sign the correct address and verify that user can now lock tokens
    let sig_info = sign_message(&priv_key1, &pub_key1, &address_to_sign1);
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: address_to_sign1.clone(),
        amount_to_lock: Uint128::new(70),
        maximum_amount: Uint128::new(70),
        proof: vec![user1_valid_proof.to_string()],
        sig_info: Some(sig_info),
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Try to lock again and verify it cannot lock more than it is allowed
    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains(&format!(
        "User cannot lock {} tokens. Currently locked: {}. Maximum allowed to lock: {}.",
        70, 70, 70,
    )));

    // Have second user lock the maximum it is allowed to
    let sig_info = sign_message(&priv_key2, &pub_key2, &address_to_sign2);
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: address_to_sign2.clone(),
        amount_to_lock: Uint128::new(30),
        maximum_amount: Uint128::new(30),
        proof: vec![user2_valid_proof.to_string()],
        sig_info: Some(sig_info),
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Register a new stage within the same epoch, but use addresses from a different chain
    // These addresses are generated from PRIVATE_KEY_BYTES_1 and PRIVATE_KEY_BYTES_2
    // Input JSON:
    // [
    //   { "address": "cosmos18jg6zhw00989l578vnrzvz7g6en9kcwffne6m6", "amount": "150"},
    //   { "address": "cosmos1jhln90cx8297qjkvmq6f3adxzav0uhpah2cv3m", "amount": "90"}
    // ]
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::from(
            "12f96c0e6e60506c1fdb3e6f8b10b2ad5dc23aab31e8b50a99619400e6e238e7",
        ),
        start_new_epoch: false,
        hrp: Some(String::from("cosmos")),
    };

    let res = execute(deps.as_mut(), env.clone(), admin_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Advance the chain to enter the second stage
    env.block.time = env.block.time.plus_hours(1);

    let user1_valid_proof = "c3d6d46335374e91e9533d60752c0eedadb81eb9305e13a7c573e29c44e5bab2";
    let user2_valid_proof = "bf9d4976fb079498209574c0eb4267fad15818a26b0534ee7eabcb0b48ce3165";

    // Have the first user lock maximum allowed for this stage, taking
    // into account it already locked 70 tokens in previous stage.
    let sig_info = sign_message(&priv_key1, &pub_key1, &address_to_sign1);
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: address_to_sign1.clone(),
        amount_to_lock: Uint128::new(80),
        maximum_amount: Uint128::new(150),
        proof: vec![user1_valid_proof.to_string()],
        sig_info: Some(sig_info),
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());

    // Have the second user lock maximum allowed for this stage
    let sig_info = sign_message(&priv_key2, &pub_key2, &address_to_sign2);
    let msg = ExecuteMsg::LockTokens(ExecuteLockTokensMsg {
        user_address: address_to_sign2.clone(),
        amount_to_lock: Uint128::new(60),
        maximum_amount: Uint128::new(90),
        proof: vec![user2_valid_proof.to_string()],
        sig_info: Some(sig_info),
    });

    let res = execute(deps.as_mut(), env.clone(), hydro_info.clone(), msg.clone());
    assert!(res.is_ok());
}

// This test verifies that only existing admins can add or remove other admins.
#[test]
fn add_remove_admin_test() {
    let (mut deps, mut env) = (mock_dependencies(), mock_env());
    env.block.time = Timestamp::from_nanos(1744012800000000000); // April 7, 2025 8:00:00 AM UTC

    let hydro_info = get_message_info(&deps.api, "hydro", &[]);
    let admin_info = get_message_info(&deps.api, "addr0000", &[]);
    let new_admin_info1 = get_message_info(&deps.api, "addr0001", &[]);
    let new_admin_info2 = get_message_info(&deps.api, "addr0002", &[]);

    let init_msg = InstantiateMsg {
        admins: vec![admin_info.sender.to_string()],
    };

    let res = instantiate(
        deps.as_mut(),
        env.clone(),
        hydro_info.clone(),
        init_msg.clone(),
    );
    assert!(res.is_ok());

    // Verify that non-admin cannot add or remove other admins
    let add_admin1_msg = ExecuteMsg::AddAdmin {
        admin: new_admin_info1.sender.to_string(),
    };
    let remove_admin1_msg = ExecuteMsg::RemoveAdmin {
        admin: new_admin_info1.sender.to_string(),
    };

    let res = execute(
        deps.as_mut(),
        env.clone(),
        new_admin_info1.clone(),
        add_admin1_msg.clone(),
    );
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains("Unauthorized"));

    let res = execute(
        deps.as_mut(),
        env.clone(),
        new_admin_info1.clone(),
        remove_admin1_msg.clone(),
    );
    assert!(res.is_err());
    assert!(res.unwrap_err().to_string().contains("Unauthorized"));

    // Use existing admin to add a new one
    let res = execute(
        deps.as_mut(),
        env.clone(),
        admin_info.clone(),
        add_admin1_msg.clone(),
    );
    assert!(res.is_ok());

    // Verify that the new admin can add and remove other admins
    let add_admin2_msg = ExecuteMsg::AddAdmin {
        admin: new_admin_info2.sender.to_string(),
    };
    let remove_admin2_msg = ExecuteMsg::RemoveAdmin {
        admin: new_admin_info2.sender.to_string(),
    };
    let res = execute(
        deps.as_mut(),
        env.clone(),
        new_admin_info1.clone(),
        add_admin2_msg.clone(),
    );
    assert!(res.is_ok());

    let res = execute(
        deps.as_mut(),
        env.clone(),
        new_admin_info1.clone(),
        remove_admin2_msg.clone(),
    );
    assert!(res.is_ok());

    // Verify that the newly added admin can register a new stage
    let msg = ExecuteMsg::RegisterStage {
        activate_at: env.block.time.plus_hours(1),
        merkle_root: String::new(),
        start_new_epoch: true,
        hrp: None,
    };

    let res = execute(
        deps.as_mut(),
        env.clone(),
        new_admin_info1.clone(),
        msg.clone(),
    );
    assert!(res.is_ok());
}

fn build_keys(private_key_bytes: &[u8]) -> (SigningKey, Vec<u8>) {
    let private_key = SigningKey::from_slice(private_key_bytes).unwrap();
    let public_key = private_key
        .verifying_key()
        .to_encoded_point(false)
        .as_bytes()
        .to_vec();

    (private_key, public_key)
}

fn public_key_to_address(pubkey: &[u8], hrp: &str) -> String {
    let sha256 = Sha256::digest(pubkey);
    let ripemd = Ripemd160::digest(sha256);
    encode::<Bech32>(Hrp::parse_unchecked(hrp), ripemd.as_slice()).unwrap()
}

fn sign_message(priv_key: &SigningKey, pub_key: &[u8], address_to_sign: &str) -> SignatureInfo {
    // Build and serialize ClaimMsg
    let claim_msg = ClaimMsg {
        address: address_to_sign.to_owned(),
    };
    let claim_msg_json = to_json_binary(&claim_msg).unwrap();

    // Hash the message and sign it
    let hash = Sha256::digest(&claim_msg_json);
    let signature: Signature = priv_key.sign(hash.as_slice());

    // Construct CosmosSignature
    let cosmos_sig = CosmosSignature {
        pub_key: Binary::from(pub_key),
        signature: Binary::from(signature.to_vec()),
    };
    let cosmos_sig_json = to_json_binary(&cosmos_sig).unwrap();

    SignatureInfo {
        claim_msg: claim_msg_json,
        signature: cosmos_sig_json,
    }
}
